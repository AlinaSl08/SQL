# SELECT

Команда `SELECT` используется в SQL, чтобы получить данные из таблицы.
То есть она не добавляет и не изменяет данные – а просто показывает то, что уже есть в базе.

Когда тестировщик хочет проверить, что:

+ заказ сохранился,
+ данные пользователя корректные,
+ статус обновился, он делает это через запрос SELECT.
 
**Синтаксис**
``` SQL
SELECT * FROM имя_таблицы;
```
                  
Здесь: 

+ `SELECT` – выбираем данные
+ `*` – все поля
+ `FROM` – из какой таблицы
 
**Пример из интернет-магазина:**

У нас есть таблица `orders`, где хранятся заказы. Чтобы вывести все заказы нужно отправить запрос: 
``` SQL
SELECT * FROM orders;
```
                  
Результат:

|id|	user_id|	total_price|	status|
|:--:|:--:|:--:|:--:|
|1|	101|	2990	|new|
|2	|102	|4900|	shipped|
|3	|103|	5990|	new|

---

Команда `SELECT` используется, чтобы получить данные из таблицы.
Иногда нам не нужны все столбцы – достаточно выбрать только нужные поля.

Это удобно, если:

+ таблица большая,
+ нужно только имя и email,
+ нужно проверить конкретные данные,
+ или просто сделать запрос понятнее.
 

**Синтаксис**
``` SQL
SELECT колонка1, колонка2

FROM имя_таблицы;
```
                  
Здесь:

+ `SELECT` – выбираем данные,
+ `колонка1, колонка2` – указываем, какие именно поля хотим,
+ `FROM` – из какой таблицы берём.
 

**Пример из интернет-магазина:**

У нас есть таблица `orders`:

|id|	user_id	|total_price|	status|
|:--:|:--:|:--:|:--:|
|1|	101|	2990|	new|
|2|	102|	4900|	shipped|
|3	|103	|5990	|new|
 

Если мы хотим посмотреть только ID заказа и статус, пишем:
``` SQL
SELECT id, status

FROM orders;
```
                  
Результат:

|id|	status|
|:--:|:--:|
|1	|new|
|2|	shipped|
|3|	new|

---

Иногда названия колонок в таблице слишком длинные, неочевидные или просто неудобные. Чтобы вывести их под другим именем – в SQL используется `AS`. Это не меняет таблицу, а просто даёт удобное название в результате запроса.

**Синтаксис**
``` SQL
SELECT имя_колонки AS новое_имя

FROM имя_таблицы;
```
                  
Здесь: 

+ `AS` – говорит: «переименовать эту колонку вот так»
+ `новое_имя` – как колонка будет отображаться в результатах
 

**Пример из интернет-магазина:**

У нас есть таблица `orders`:

|id	|user_id|	total_price|	status|
|:--:|:--:|:--:|:--:|
|1|	101|	2990|	new|
|2|	102|	4900	|shipped|
|3|	103|	5990|	new|

Допустим, мы хотим, чтобы `total_price` называлась просто `цена`. 
``` SQL
SELECT id, total_price AS цена

FROM orders;
```
                  
Результат:

|id|	цена|
|:--:|:--:|
|1|	2990|
|2	|4900|
|3|	5990|

---

Команда `SELECT` показывает все строки. А `WHERE` позволяет выбрать только те, которые соответствуют условию:

**Синтаксис**
``` SQL
SELECT поля

FROM таблица

WHERE условие;
```
                  
 

Операторы сравнения, которые часто используются:

|Оператор|	Что значит|	Пример|
|:--:|:--:|:--:|
|`=`|	Равно	|`status = 'new'`|
|`!=`|	Не равно|	`status != 'shipped'`|
|`<`|	Меньше|	`total_price < 3000`|
|`>`|	Больше|	`total_price > 5000`|
|`<=`	|Меньше или равно|	`total_price <= 5000`|
|`>=`|	Больше или равно|	`total_price >= 3000`|


---

Когда нужно указать несколько условий в запросе — используется `AND` и `OR`.

+ `AND` – оба условия должны быть выполнены
+ `OR` – достаточно одного из условий
  
**Пример c AND:**
``` SQL
SELECT * FROM orders

WHERE status = 'new' AND total_price > 3000;
```
                  
Покажет только заказы, где статус `new` и цена больше 3000.

**Пример с OR:**
``` SQL
SELECT * FROM orders

WHERE status = 'new' OR total_price > 3000;
```
                  
Покажет строки, где или статус `new`, или цена больше 3000.

---

В SQL можно проверять:

+ входит ли значение в список (`IN`)
+ не входит ли в список (`NOT IN`)
+ попадает ли значение в диапазон (`BETWEEN`)
  
**Пример с IN:**
``` SQL
SELECT * FROM orders

WHERE status IN ('new', 'processing');
```
                  
Все заказы, у которых статус или `new`, или `processing`.

 

**Пример с NOT IN:**
``` SQL
SELECT * FROM orders

WHERE user_id NOT IN (101, 104);
```
                  
Все строки, где `user_id` не равен ни 101, ни 104.

 

**Пример с BETWEEN:**
``` SQL
SELECT * FROM orders

WHERE total_price BETWEEN 3000 AND 5000;
```
                  
Только те заказы, где сумма от 3000 до 5000 включительно.

---

Команда `LIKE` в SQL используется, чтобы находить строки, где поле содержит определённый текст – например, часть имени, статус, описание товара и т.д.

Это особенно полезно, когда:

+ Найти пользователя по фамилии или части фамилии
+ Найти заказ со статусом, начинающимся на new
+ Найти продукт, где в названии есть слово хлопковое
+ Найти строки, где есть номер, код, часть email и т.д.

**Синтаксис:**
``` sql
SELECT * 

FROM таблица

WHERE поле LIKE 'шаблон';
```
                  
В шаблоне можно использовать специальные символы:

|Шаблон|	Что |означает|
|:--:|:--:|:--:|
|`%`|	Любое количество символов|
|`_`|	Один любой символ|
 

**Примеры: как работает `LIKE`**

1. `%ТЕКСТ%` – содержит слово в любом месте
``` sql
SELECT * FROM products WHERE name LIKE '%скидка%';
```
                  
Найдёт:

+ Большая скидка
+ Без скидки
+ Скидка до 50%
 

2. `ТЕКСТ%` – начинается со слова
``` sql
SELECT * 

FROM orders

WHERE status LIKE 'new%';
```
                  
Найдёт:

+ new
+ new_payment
+ new_manual

Не найдёт:

+ renewed
+ is_new
 

3. `%ТЕКСТ` – заканчивается на слово
``` sql
SELECT * 

FROM orders

WHERE status LIKE '%ed';
```
                  
Найдёт:

+ shipped
+ processed
+ canceled

---

В SQL символ `_` в команде `LIKE` означает ровно один любой символ. И таких символов `_` может быть несколько в шаблоне.

**Синтаксис:**
``` sql
SELECT * 

FROM products

WHERE code LIKE 'A_1';
```
                  
**Здесь:**

+ `A` – первый символ должен быть именно `A`
+ `_` – любой один символ (буква, цифра, знак)
+ `1` – третий символ должен быть `1`

То есть строка должна быть длиной ровно 3 символа.

**Подходящие примеры:**

|Строка|	Почему подходит|
|:--:|:--:|
|`A11`|	второй символ – 1|
|`AB1`|	второй символ – B|
|`A_1`|	`_` – тоже символ|

**Неподходящие примеры:**

|Строка|	Почему не подходит|
|:--:|:--:|
|`AA11`|	слишком длинно (4 символа)|
|`A1`|	слишком коротко|
|`AB11`|	4 символа – не совпадает по длине|

---

`ORDER BY` в SQL используется для сортировки результатов запроса. По умолчанию сортировка идёт по возрастанию (`ASC`), но можно указать обратный порядок с помощью `DESC`. Можно сортировать по одному или нескольким столбцам.

**Синтаксис**
``` sql
SELECT ... 

FROM таблица

ORDER BY поле1 [ASC|DESC], поле2 [ASC|DESC], ...;
```
                  
+ `ASC` (ascending) — по возрастанию (по умолчанию)
+ `DESC` (descending) — по убыванию
 

**Пример из интернет-магазина:**

**Таблица `orders`**

|id|	user_id|	total_price|	status|
|:--:|:--:|:--:|:--:|
|1|	101|	2990|	new|
|2|	102|	4900|	shipped|
|3|	103|	5990|	new|
|4|	104|	3990|	shipped|
 

**Сортировка по возрастанию:**
``` sql
SELECT * FROM orders ORDER BY total_price;
```
                  
Результат: от самой низкой суммы к самой высокой.

**Таблица `orders` (после запроса)**

|id	|user_id|	total_price|	status|
|:--:|:--:|:--:|:--:|
|1|	101	|2990	|new|
|4|	104|	3990|	shipped|
|2|	102|	4900	|shipped|
|3|	103	|5990|	new|
 

**Сортировка по убыванию**
``` sql
SELECT * FROM orders ORDER BY total_price DESC;
```
                  
Результат: сначала самые дорогие заказы.

**Таблица `orders` (после запроса)**

|id|	user_id|	total_price|	status|
|:--:|:--:|:--:|:--:|
|3|	103|	5990	|new|
|2|	102|	4900|	shipped|
|4|104|	3990	|shipped|
|1|	101|	2990|	new|
 
**Сортировка по нескольким столбцам**
``` sql
SELECT *
 
FROM orders

ORDER BY status, total_price DESC;
```
                  
Результат: сначала сортирует по `status` в алфавитном порядке,
а внутри каждой группы по `total_price` (от большего к меньшему).

**Таблица `orders` (после запроса)**

|id	|user_id|	total_price|	status|
|:--:|:--:|:--:|:--:|
|3|	103|	5990|	new|
|1|	101|	2990|	new|
|2|	102|	4900|	shipped|
|4|	104|	3990|	shipped|

---

Команда `LIMIT` используется в SQL, чтобы ограничить количество строк, которые возвращает запрос.

Это особенно полезно, когда:

+ данных в таблице много,
+ нужно посмотреть только первые строки,
+ тестировщик проверяет корректность сортировки,
+ нужно быстро посмотреть срез данных, а не всю таблицу.

**Синтаксис**
``` sql
SELECT * 

FROM таблица

LIMIT число;
```
                  
+ LIMIT 5 — вернуть только первые 5 строк.
+ Если строк меньше — вернёт все.
 

**Пример из интернет-магазина:**

**Таблица `orders`**

|id|	user_id|	total_price|	status|
|:--:|:--:|:--:|:--:|
|1|	101|	2990|	new|
|2|	103	|5900	|shipped|
|3|	102|	1500	|new|
|4|	104	|4990	|canceled|
|5	|105	|990	|new|
 

**Получить только первые 3 заказа**
``` sql
SELECT * 

FROM orders 

LIMIT 3;
```
                  
**Результат:**

|id|	user_id|	total_price|	status|
|:--:|:--:|:--:|:--:|
|1|	101|	2990|	new|
|2|	103|	5900|	shipped|
|3|	102|	1500|	new|

---
# Агрегационные функции

**Агрегационные функции** используются в SQL, чтобы посчитать или вычислить что-то по столбцам таблицы. Они не выводят строки – они возвращают одно вычисленное значение.

Используются тестировщиками, когда нужно:

+ посчитать количество заказов
+ узнать максимальную сумму покупки
+ проверить, что средняя цена товара корректная
+ убедиться, что сумма всех платежей совпадает с отчётом
+ проверить корректность статистики и отчётных данных

**Основные агрегатные функции**

|Функция|	Что делает|
|:--:|:--:|
|**COUNT()**|	Считает количество строк|
|**MIN()**|	Находит минимальное значение|
|**MAX()**|	Находит максимальное|
|**SUM()**|	Складывает все значения|
|**AVG()**|	Считает среднее|

**Примеры из интернет-магазина:**

**таблица `orders`:**

|id	|user_id|	total_price|	status|
|:--:|:--:|:--:|:--:|
|1|	101|	2990|	new|
|2|	103|	5900|	shipped|
|3|	102|	1500|	new|
|4|101	|7000|	new|
 

`COUNT` для подсчета количества строк:
``` sql
Общее количество заказов: SELECT COUNT(*) FROM orders;
```              
Результат: 4

```sql
Заказов со статусом new: SELECT COUNT(*) FROM orders WHERE status = 'new';
```                 
Результат: 3
```sql
Назвать столбец с результатом можно так: SELECT COUNT(*) total_orders FROM orders
```

---

**Примеры из интернет-магазина:**

**таблица `orders`:**

|id|	user_id|	total_price	|status|
|:--:|:--:|:--:|:--:|
|1|	101	|2990|	new|
|2|	103|	5900|	shipped|
|3|	102|	1500|	new|
|4|	101|	7000|	new|
 

`MIN` и `MAX` для подсчета минимального и максимального значения:
``` sql
Минимальная сумма заказа: SELECT MIN(total_price) FROM orders;
```
                  
Результат: 1500
``` sql
Максимальная сумма заказа: SELECT MAX(total_price) FROM orders;
```
                  
Результат: 7000

---

**Пример из интернет-магазина:**

**таблица `orders`:**

|id|	user_id|	total_price	|status|
|:--:|:--:|:--:|:--:|
|1|	101|	2990	|new|
|2	|103|	5900|	shipped|
|3|	102|	1500|	new|
|4|	101|	7000|	new|
 
`SUM` для подсчета суммы:
``` sql
Считаем сумму всех заказов: SELECT SUM(total_price) FROM orders;
```
                  
Результат: 17390

---

**Примеры из интернет-магазина:**

**таблица `orders`:**

|id|	user_id|	total_price	|status|
|:--:|:--:|:--:|:--:|
|1|	101|	2990	|new|
|2	|103|	5900|	shipped|
|3|	102|	1500|	new|
|4|	101|	7000|	new|
 

`AVG` для подсчета среднего значения:
``` SQL
Считаем среднее значение цены всех заказов: SELECT AVG(total_price) FROM orders;
```
                  
Результат: 4347.5

+ Важно: результат может быть дробным числом.

---

`GROUP BY` позволяет сгруппировать строки, имеющие одинаковые значения в указанных столбцах, в одну строку сводки. Он обычно используется в сочетании с агрегатными функциями (такими как `COUNT()`, `SUM()`, `AVG()`, `MIN()`, `MAX()`), чтобы выполнять вычисления над каждой группой, а не над всей таблицей целиком.

**Синтаксис:**
``` SQL
SELECT столбец_группировки, агрегатная_функция(...)

FROM таблица

GROUP BY столбец_группировки;
```
                  

**Пример интернет-магазин:**

**таблица `orders`:**

|id|	user_id|	total_price	|status|
|:--:|:--:|:--:|:--:|
|1|	101|	2990	|new|
|2	|103|	5900|	shipped|
|3|	102|	1500|	new|
|4|	101|	7000|	new|
 

**Примеры запросов:**
``` SQL
Запросить количество заказов по статусам: SELECT status, COUNT(*) AS order_count FROM orders GROUP BY status;
```
                  
Результат:

|status|	order_count|
|:--:|:--:|
|new	|3|
|shipped|	1|
 
``` SQL
Запросить сколько потратил каждый пользователь: SELECT user_id, SUM(total_price) AS total_spent FROM orders GROUP BY user_id;
```
                  
Результат:

|user_id|	total_spent|
|:--:|:--:|
|101	|9990|
|102	|1500|
|103	|5900|

---

`HAVING` позволяет отфильтровать группы строк после их группировки (через GROUP BY), проверяя условия на агрегатные значения — такие как `SUM`, `COUNT`, `AVG`, `MAX`, `MIN` и др.

**Синтаксис**
``` SQL
SELECT столбцы, агрегатные_функции

FROM таблица

GROUP BY столбцы

HAVING условие_для_агрегатов;
```

**Пример из интернет-магазина:**

**таблица `orders`**

|id	|user_id|	total_price	|status|
|:--:|:--:|:--:|:--:|
|1|	101|	2990|	new|
|2|	103|	5900|	shipped|
|3|	101|	7000|	new|
|4|	102|	1500|	new|
|5|	101|	3200|	shipped|

**запросить пользователей, у которых сумма заказов больше 5 000:**
``` SQL
SELECT user_id, SUM(total_price) AS total_sum

FROM orders

GROUP BY user_id

HAVING SUM(total_price) > 5000;
```
                  
**результат: **

|user_id	|total_sum|
|:--:|:--:|
|101|	13| 190|
|103|	5| 900|

---
# JOIN

**JOIN** – это оператор SQL, который объединяет данные из двух или более таблиц по общему столбцу (обычно – по ключу).

Связь между таблицами строится через **ключи**:

+ **Первичный ключ (PRIMARY KEY)** – уникальный идентификатор строки (в таблице `users` столбец `id`).
+ **Внешний ключ (FOREIGN KEY)** – поле, которое ссылается на другую таблицу (таблица `orders` столбец `user_id` ссылается на `id` из таблицы `users`).
 

**Общий синтаксис JOIN**
``` SQL
SELECT столбцы

FROM таблица1

JOIN таблица2 ON условие_соединения;
```
                  
Где:

+ `таблица1` – "левая" таблица
+ `таблица2` – "правая" таблица
+ `ON` – указывает, по каким полям связываем строки (чаще всего `PRIMARY KEY` ↔ `FOREIGN KEY`)
 

**Типы JOIN**

|Тип JOIN|	Что делает|
|:--:|:--:|
|`INNER JOIN`|	Только совпадающие строки из обеих таблиц|
|`LEFT JOIN`	|Все строки из левой таблицы и совпадающие из правой|
|`RIGHT JOIN`	|Все строки из правой таблицы и совпадающие из левой|
|`FULL JOIN*`	|Все строки из обеих таблиц|

***MySQL не поддерживает `FULL JOIN` напрямую, но можно эмулировать через `UNION`.**

---
# Алиасы

**Алиасы (Aliases)** – это временное имя, присваиваемое таблице, столбцу или подзапросу **в рамках конкретного SQL‑запроса**. 

Не изменяет исходные названия в базе данных – действует только внутри запроса.

**Синтаксис**
``` SQL
original_name AS alias_name
```
                  
Пример:
``` SQL
SELECT c.customer_name, o.product

FROM customers AS c

JOIN orders AS o ON c.id = o.customer_id;
```
                  
+ c – алиас для customers
+ o – алиас для orders

---

`INNER JOIN` (просто `JOIN`) возвращает только те строки, для которых нашлась пара **и в левой, и в правой** таблице.

**левая таблица `users`**

|id	|name|
|:--:|:--:|
|1|	Иван Петров|
|2|	Елена Орлова|
|3|	Алексей Иванов|

**правая таблица `orders`**

|id	|user_id|	total_price|
|:--:|:--:|:--:|
|101	|1|	2990|
|102	|2|	4500|
|103	|1|	3990|
 

**Запрос:**
``` SQL
SELECT u.name, o.total_price

FROM users AS u

INNER JOIN orders AS o ON u.id = o.user_id
```
                  
**Результат:**

|name|	total_price|
|:--:|:--:|
|Иван Петров|	2990|
|Елена Орлова|	4500|
|Иван Петров	|3990|

**Важно**: Пользователь Алексей Иванов в результат не попадёт, потому что у него нет заказов – нечего соединять.

---

`LEFT JOIN` возвращает все строки из левой таблицы, подходящие строки из правой, а там, где пары нет – подставляет NULL в поля правой таблицы.

**левая таблица `users`**

|id|	name|
|:--:|:--:|
|1|	Иван Петров|
|2|	Елена Орлова|
|3|	Алексей Иванов|

**правая таблица `orders`**

|id|	user_id	|total_price|
|:--:|:--:|:--:|
|101	|1|	2990|
|102	|2	|4500|
|103|	1|	3990|
 

**Запрос:**
``` sql
SELECT u.name, o.total_price

FROM users AS u

LEFT JOIN orders AS o ON u.id = o.user_id;
```
                  
**Результат:**

|name|	total_price|
|:--:|:--:|
|Иван Петров|	2990|
|Елена Орлова	|4500|
|Иван Петров|	3990|
|Алексей Иванов|	NULL|

**Важно**: Строка с Алексеем появилась, но `total_price = NULL`, так как заказов нет.
